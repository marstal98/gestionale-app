// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  // Use SQLite for local development in the unified workspace.
  // In production, override DATABASE_URL in the environment with a postgres URL.
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                    Int             @id @default(autoincrement())
  name                  String
  email                 String          @unique
  password              String // hash bcrypt
  role                  Role            @default(customer)
  isActive              Boolean         @default(true)
  // who created this user (nullable)
  createdById           Int?
  createdBy             User?           @relation("UserCreatedBy", fields: [createdById], references: [id])
  createdUsers          User[]          @relation("UserCreatedBy")
  // products created by this user
  productsCreated       Product[]       @relation("ProductCreatedBy")
  // orders assigned to this user (could be employee or customer)
  assignedOrders        Order[]         @relation("OrderAssignedTo")
  // orders where this user is the customer
  customerOrders        Order[]         @relation("OrderCustomer")
  // orders created by this user (admin or customer creating on their behalf)
  createdOrders         Order[]         @relation("OrderCreatedBy")
  // orders deleted by this user (soft-delete)
  deletedOrders         Order[]         @relation("OrderDeletedBy")
  // invitations received (user invited to join)
  invitationsReceived   Invitation[]    @relation("InvitationUser")
  // invitations created by this user (admin who invited)
  invitationsCreated    Invitation[]    @relation("InvitationCreatedBy")
  // access requests handled by this user (admin actions)
  handledAccessRequests AccessRequest[] @relation("AccessRequestHandledBy")
  // assignments: customers assigned to this user (when acting as employee)
  customerAssignmentsAsEmployee CustomerAssignment[] @relation("EmployeeAssignments")
  // assignments: employees assigned to this user (when acting as customer)
  customerAssignmentsAsCustomer CustomerAssignment[] @relation("CustomerAssignments")
  createdAt             DateTime        @default(now())
}

enum Role {
  admin
  employee
  customer
}

model Product {
  id                 Int                 @id @default(autoincrement())
  name               String
  sku                String?             @unique
  price              Float
  stock              Int                 @default(0)
  // who created this product
  createdById        Int?
  createdBy          User?               @relation("ProductCreatedBy", fields: [createdById], references: [id])
  createdAt          DateTime            @default(now())
  orderItems         OrderItem[]
  inventoryMovements InventoryMovement[]
}

enum OrderStatus {
  draft
  pending
  in_progress
  completed
  cancelled
}

model Order {
  id           Int         @id @default(autoincrement())
  // the customer for whom the order is placed
  customer     User?       @relation("OrderCustomer", fields: [customerId], references: [id])
  customerId   Int?
  // the user who created the order (could be admin or the customer themselves)
  createdBy    User?       @relation("OrderCreatedBy", fields: [createdById], references: [id])
  createdById  Int?
  // Optional assignee: can be a customer or an employee (references User)
  assignedTo   User?       @relation("OrderAssignedTo", fields: [assignedToId], references: [id])
  assignedToId Int?
  total        Float
  status       OrderStatus @default(pending)
  createdAt    DateTime    @default(now())
  items        OrderItem[]
  // soft-delete metadata
  deletedAt    DateTime?
  deletedBy    User?       @relation("OrderDeletedBy", fields: [deletedById], references: [id])
  deletedById  Int?
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  order     Order   @relation(fields: [orderId], references: [id])
  orderId   Int
  product   Product @relation(fields: [productId], references: [id])
  productId Int
  quantity  Int
  unitPrice Float
}

model InventoryMovement {
  id        Int      @id @default(autoincrement())
  product   Product  @relation(fields: [productId], references: [id])
  productId Int
  type      String // 'adjust' | 'reserve' | 'release' | 'sale'
  quantity  Int
  metadata  Json?
  createdAt DateTime @default(now())
}

// Assignments between customers and employees (many-to-many)
model CustomerAssignment {
  id         Int      @id @default(autoincrement())
  customer   User     @relation("CustomerAssignments", fields: [customerId], references: [id])
  customerId Int
  employee   User     @relation("EmployeeAssignments", fields: [employeeId], references: [id])
  employeeId Int
  createdAt  DateTime @default(now())

  @@unique([customerId, employeeId])
  @@index([employeeId])
  @@index([customerId])
}

// Requests coming from users who want access
model AccessRequest {
  id          Int       @id @default(autoincrement())
  name        String
  email       String
  company     String?
  message     String?
  status      String    @default("pending") // pending|accepted|rejected
  createdAt   DateTime  @default(now())
  handledById Int?
  handledBy   User?     @relation("AccessRequestHandledBy", fields: [handledById], references: [id])
  handledAt   DateTime?
}

// Invitation tokens for onboarding (single-use)
model Invitation {
  id          Int       @id @default(autoincrement())
  email       String
  token       String    @unique
  // the user account linked to this invitation (if already created)
  user        User?     @relation("InvitationUser", fields: [userId], references: [id])
  userId      Int?
  createdById Int?
  // the admin who created the invitation
  createdBy   User?     @relation("InvitationCreatedBy", fields: [createdById], references: [id])
  expiresAt   DateTime
  usedAt      DateTime?
  createdAt   DateTime  @default(now())
}
